David Walker  April 8, 2019


  0  Collapse this comment
Copy link
Do newer processors have a (single) "decrement and jump if zero" atomic instruction, built into the hardware?  Or, a decrement like you mention that can decrement a value at a memory location and set a flag, all interlocked at the CPU level (and multiprocessor-safe)?
I realize that decrementing from a memory location usually involves reading the value into a register, decrementing the register, and writing the value back out.  But, if you can specify a...Read moreDo newer processors have a (single) “decrement and jump if zero” atomic instruction, built into the hardware?  Or, a decrement like you mention that can decrement a value at a memory location and set a flag, all interlocked at the CPU level (and multiprocessor-safe)?
I realize that decrementing from a memory location usually involves reading the value into a register, decrementing the register, and writing the value back out.  But, if you can specify a memory location (and size) in the instruction, the silicon could be smart enough to decrement with appropriate memory barriers and set a flag, in the same instruction.  It’s not very RISC, but these are not RISC processors.
Read less







cheong00  April 8, 2019


  0  Collapse this comment
Copy link
Do you mean “LOOPZ”? (decrements CX and jump to label if zero and ZF is set, although the jump range is limited)





David Walker  April 9, 2019


  0  Collapse this comment
Copy link
I was actually looking for an atomic increment or decrement of a memory location, not a register.





Raymond Chen Author
April 9, 2019


  0  Collapse this comment
Copy link
Yup, it’s right there in the article. But all you get is the sign, not the value. See also the link at the end of the article.





David Walker  April 12, 2019


  0  Collapse this comment
Copy link
Oh, right.  Thanks.





Yuhong Bao  April 16, 2019


  0  Collapse this comment
Copy link
FYI, if you code in x86 assembly, you can use any flags generated by the LOCK DEC/SUB/ADD/INC instructions after it is executed.



Alex Cohn  April 6, 2019


  0  Collapse this comment
Copy link
The self-imposed race conditions between two threads running on a single CPU can be handled without atomics. E.g. given i that another thread can change, `int local_copy_of_i = i+1; i = local_copy_of_i; if (local_copy_of_i > 10) do_something(); else do_something_else();` I believe it will even resolve DMA race conditions.





Murray Colpman  June 6, 2019


  0  Collapse this comment
Copy link
This wouldn't work if two increments of i is expected to increment i twice. Say i is 0, your local thread takes local_copy_of_i to be 1. Then you're preempted and another thread does the same, taking its local_copy_of_i to be 1. The other thread writes back the incremented value 1, and then your thread also writes back the local_copy_of_i which is still 1. Oops - you've incremented i twice from 0 and got 1!
Read moreThis wouldn’t work if two increments of i is expected to increment i twice. Say i is 0, your local thread takes local_copy_of_i to be 1. Then you’re preempted and another thread does the same, taking its local_copy_of_i to be 1. The other thread writes back the incremented value 1, and then your thread also writes back the local_copy_of_i which is still 1. Oops – you’ve incremented i twice from 0 and got 1!
Read less






Yuhong Bao  April 4, 2019


  0  Collapse this comment
Copy link
Actually, there is nothing preventing the 80386 from supporting SMP and NT 3.1 did support it with Compaq SystemPro I think. It is not common though.





Jernej Simončič  April 5, 2019


  0  Collapse this comment
Copy link
Wasn’t SystemPro asymmetric?





Piotr Gliźniewicz  April 5, 2019


  0  Collapse this comment
Copy link
Yes, the SystemPro was asymmetric, it used the 2nd CPU for I/O. I think “80386 processor did not support symmetric multiprocessing” means more “80386 processor did not support symmetric multiprocessing out of the box”. You could build a multiprocessor using 8080s with enough external logic. I’m not an expert on the topic, but I think if a CPU supports external bus masters it should also be possible to build an SMP system with it.





Yuhong Bao  April 5, 2019


  0  Collapse this comment
Copy link
AFAIK the 80386 and 80486 bus was very similar