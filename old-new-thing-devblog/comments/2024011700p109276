GL  January 17, 2024
· Edited

  0  Collapse this comment
Copy link
The choice of `InitializeComponent` instead of `initialize_instance` as originally proposed in the GitHub issue will be a scar forever. The name `InitializeComponent` adheres to COM interface method naming convention and is divorced from the usual pattern of C++/WinRT that non-COM methods are snake-cased. The deviation might come to bite people, and I really don't like the attitude that (novice?) programmers should be shielded from nuances ("there is some utility to this functionality, but I'm persuaded...Read moreThe choice of `InitializeComponent` instead of `initialize_instance` as originally proposed in the GitHub issue will be a scar forever. The name `InitializeComponent` adheres to COM interface method naming convention and is divorced from the usual pattern of C++/WinRT that non-COM methods are snake-cased. The deviation might come to bite people, and I really don’t like the attitude that (novice?) programmers should be shielded from nuances (“there is some utility to this functionality, but I’m persuaded we shouldn’t go out of our way to advertise it”).
As for ATL, according to the Old New Thing (!), ATL “play[s] with matches” and initializes the reference count to zero by default. This makes it dangerous to hand out `this` as a COM reference in the constructor already, regardless of whether the constructor throws. (See https://devblogs.microsoft.com/oldnewthing/20050929-10/?p=34003 ) The ATL magic word is `FinalConstruct`, I think? And you have to protect `FinalConstruct`, because ATL continues to play with matches after the constructor and during `FinalConstruct`.
Read less