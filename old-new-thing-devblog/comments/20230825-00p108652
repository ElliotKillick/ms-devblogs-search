Joshua Hudson  August 30, 2023


  0  Collapse this comment
Copy link
I don‚Äôt know about the other languages, but you should in fact *not* use ContinueWith like that in C#. The problem is ContinueWith doesn‚Äôt enqueue another asynchronous action, but runs the method on completion of the previous action. So if your loop body is mostly synchronous you pile up a lot of stack as you call ContinueWith recursively.





Georg Rottensteiner  August 25, 2023


  0  Collapse this comment
Copy link
I‚Äôm seriously wary of the convoluted async stuff, unless there‚Äôs good reason to use it. It‚Äôs a bit viral as it spreads through the code üôÇ
Anyhow, I think the C++ example should also use widgets[i].





Á¥ÖÊ®ìÈçÆ  August 26, 2023


  0  Collapse this comment
Copy link
It's a bit viral as it spreads through the code
If you're not using stackful coroutines, an asynchronous function has to either be in continuation-passing style (accepting a completion callback), or return a future object (, , etc) which is equivalent to continuation-passing style (the completion callback is passed to the future object's ). It cannot have the same signature as a synchronous function.
Read moreIt‚Äôs a bit viral as it spreads through the code
If you‚Äôre not using stackful coroutines, an asynchronous function has to either be in continuation-passing style (accepting a completion callback), or return a future object (task<T>, IAsyncOperation<T>, etc) which is equivalent to continuation-passing style (the completion callback is passed to the future object‚Äôs await_suspend()). It cannot have the same signature as a synchronous function.
Read less