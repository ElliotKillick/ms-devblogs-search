David Flicek  July 18, 2020


  0  Collapse this comment
Copy link
OT: But I couldn't find a suggestion box or contact.   What I really want to know is why are the desktop icons are starting at x:13 and y:2 yet the left side is at 0 on the screen and the top is down about 4?  If you take an icon on the right most column, add the spacing size, it goes beyond the end of the work area (monitor) (or virtual screen...Read moreOT: But I couldn’t find a suggestion box or contact.   What I really want to know is why are the desktop icons are starting at x:13 and y:2 yet the left side is at 0 on the screen and the top is down about 4?  If you take an icon on the right most column, add the spacing size, it goes beyond the end of the work area (monitor) (or virtual screen – single monitor), but if do the math taking the POINT x:2488 subtract 13 then divide by 75 (my desktop reported icon spacing via IFolderView2 is 75×100) it works out as the even multiple expected.  So where does this mystery skew of 13 and 2 come from?  I looked the the IShellView window rect starts at 0, 0 to end of screen, I checked the handle returned by IShellWindows::FindWindowSW and it was 0,0 to end of screen.   Is it just hard coded or is there a way to get it?  Thanks.
Read less







Richard Smith  July 17, 2020


  0  Collapse this comment
Copy link
It seems to me that your task would be easier if you use function overloading instead of class template specializations:
<code>
We don't need to worry about collisions here, since they'll just be harmless redeclarations of the same template. Overload sets can also be generated by pack expansion, which could save you some duplication (though in this case it's probably not worth worrying about).
Read moreIt seems to me that your task would be easier if you use function overloading instead of class template specializations:
template auto function_traits_impl(R(*)(Args...)) -> FunctionTraitsBase;
template auto function_traits_impl(R(__cdecl*)(Args...)) -> FunctionTraitsBase;
template auto function_traits_impl(R(__stdcall*)(Args...)) -> FunctionTraitsBase;
template auto function_traits_impl(R(__fastcall*)(Args...)) -> FunctionTraitsBase;
template using FunctionTraits = decltype(function_traits_impl((F*)nullptr));

We don’t need to worry about collisions here, since they’ll just be harmless redeclarations of the same template. Overload sets can also be generated by pack expansion, which could save you some duplication (though in this case it’s probably not worth worrying about).
Read less