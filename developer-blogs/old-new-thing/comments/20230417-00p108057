Jeremy Richards  April 19, 2023


  0  Collapse this comment
Copy link
One of my biggest frustrations when onboarding junior developers is convincing them that they need to keep the output window open and not just rely on the error window because it lacks context and sometimes has incomplete messages.





紅樓鍮  April 17, 2023


  0  Collapse this comment
Copy link
Though aren’t you going to talk about why a C++/WinRT implementation class can’t be final, and what winrt::impl::heap_implements is and what its purpose is? I don’t think it’ll be easy for the programmer to find the answer without reading that specific blog post by Kenny Kerr.





ஜெய்கணேஷ் குமரன்  April 18, 2023


  0  Collapse this comment
Copy link
This was to disallow putting the WinRT implementation type on the stack or inside a C++ smart pointer type that's incompatible with the COM reference counting model.
In C++/WinRT version 1, all these would compile and were a significant source of bugs. Even the code generated by the XAML compiler did this mistake.
<code>
To prevent instantiating the type directly like this and ensure you go through winrt::make or winrt::make_self, in C++/WinRT version 2, they made the base class abstract with a pure virtual function named "use_make_function_to_create_this_object". You as the type author don't know that this exists unless you read the source and...Read moreThis was to disallow putting the WinRT implementation type on the stack or inside a C++ smart pointer type that’s incompatible with the COM reference counting model.
In C++/WinRT version 1, all these would compile and were a significant source of bugs. Even the code generated by the XAML compiler did this mistake.
struct T : winrt::implements {};

T t;
std::unique_ptr t = std::make_unique();
std::shared_ptr t = std::make_shared();

To prevent instantiating the type directly like this and ensure you go through winrt::make or winrt::make_self, in C++/WinRT version 2, they made the base class abstract with a pure virtual function named “use_make_function_to_create_this_object”. You as the type author don’t know that this exists unless you read the source and won’t naturally implement the function. This prevents you from instantiating the type directly.
The struct template “winrt::impl::heap_implements” derives from your type and overrides the use_make_function_to_create_this_object, providing a dummy implementation so it is no longer abstract and can be instantiated. Basically winrt::make and winrt::make_self now “new up” heap_implements and wrap it in an appropriate smart pointer type (eg: com_ptr or a WinRT projected type).
Of course, having this pure virtual function has an overhead, so it is disabled in release mode. You can also disable it in debug mode by defining WINRT_NO_MAKE_DETECTION.
Read less