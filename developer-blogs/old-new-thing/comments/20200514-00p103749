Alex Martin  May 18, 2020


  0  Collapse this comment
Copy link
Footnote 4 was just an excuse for you to play with some Itanium, wasnâ€™t it? ğŸ™‚





Raymond Chen Author
May 18, 2020


  0  Collapse this comment
Copy link
It was the first platform I could think of that used fat function pointers. I guess I couldâ€™ve used PowerPC. But I admit to having chosen Itanium on purposeâ€¦




philiplu  May 14, 2020


  0  Collapse this comment
Copy link
Alright, if no one else is going to mention it, I will.  Itanium asm code?!?  Thanks for the nasty flashbacks from 20 years ago.





Jacob Manaker  May 14, 2020


  0  Collapse this comment
Copy link
Why does the std::function move constructor bother to annul and destruct other.m_callable immediately after calling other.m_callable->move_to?
If left as-is, the object referenced by â€œotherâ€ will, in the course of its destruction, end up destructing *other.m_callable anyways.





Raymond Chen Author
May 15, 2020


  0  Collapse this comment
Copy link
Thatâ€™s what Microsoft Visual C++â€™s implementation does.




Adam Rosenfield  May 14, 2020


  0  Collapse this comment
Copy link
In the first case of the function move constructor, you wrote:
<code>
with the description:
> If the callable is small (the m_callable points to our storage), then move it into the destinationâ€™s storage and destruct the original, leaving the source empty.
Shouldn't this be testing if (other.m_callable == other.storage())?  And correspondingly, shouldn't "our storage" in the description say "the source's storage"?  Unless I'm misunderstanding something, I don't see how the other's callable could be pointing at the storage of a new object that is just being constructed now.
Read moreIn the first case of the function move constructor, you wrote:
  function(function&& other)
  {
    if (other.m_callable == storage()) {
with the description:
> If the callable is small (the m_callable points to our storage), then move it into the destinationâ€™s storage and destruct the original, leaving the source empty.
Shouldnâ€™t this be testing if (other.m_callable == other.storage())?  And correspondingly, shouldnâ€™t â€œour storageâ€ in the description say â€œthe sourceâ€™s storageâ€?  Unless Iâ€™m misunderstanding something, I donâ€™t see how the otherâ€™s callable could be pointing at the storage of a new object that is just being constructed now.
Read less







Raymond Chen Author
May 14, 2020


  0  Collapse this comment
Copy link
Yeah, youâ€™re right.





Ryan P  May 14, 2020


  0  Collapse this comment
Copy link
I was just thinking the same thing.