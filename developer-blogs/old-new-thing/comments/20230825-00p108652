Joshua Hudson  August 30, 2023


  0  Collapse this comment
Copy link
I donâ€™t know about the other languages, but you should in fact *not* use ContinueWith like that in C#. The problem is ContinueWith doesnâ€™t enqueue another asynchronous action, but runs the method on completion of the previous action. So if your loop body is mostly synchronous you pile up a lot of stack as you call ContinueWith recursively.





Georg Rottensteiner  August 25, 2023


  0  Collapse this comment
Copy link
Iâ€™m seriously wary of the convoluted async stuff, unless thereâ€™s good reason to use it. Itâ€™s a bit viral as it spreads through the code ğŸ™‚
Anyhow, I think the C++ example should also use widgets[i].





ç´…æ¨“é®  August 26, 2023


  0  Collapse this comment
Copy link
Itâ€™s a bit viral as it spreads through the code
If youâ€™re not using stackful coroutines, an asynchronous function has to either be in continuation-passing style (accepting a completion callback), or return a future object (task<T>, IAsyncOperation<T>, etc) which is equivalent to continuation-passing style (the completion callback is passed to the future objectâ€™s await_suspend()). It cannot have the same signature as a synchronous function.